#include  <msp430g2553.h>
#include <stdint.h>
#include <stdlib.h>

volatile unsigned char *ports[3];
int pins[3][3] = {
		{BIT2, BIT1, BIT0}, 
		{BIT3, BIT4, BIT5}, 
		{BIT0, BIT1, BIT2}};

const uint16_t *current_image;
		
int current_frame = 0;
		
#define NUMBER_OF_FRAMES	91
		
const uint16_t animation[][3] = {
	/* 9 frames */
	{0xF00, 0xF00, 0xF00},
	{0xF00, 0xF00, 0xF00},
	{0xF00, 0xF00, 0xF00},
	{0x0F0, 0x0F0, 0x0F0},
	{0x0F0, 0x0F0, 0x0F0},
	{0x0F0, 0x0F0, 0x0F0},
	{0x00F, 0x00F, 0x00F},
	{0x00F, 0x00F, 0x00F},
	{0x00F, 0x00F, 0x00F},
	
	/* 9 frames */
	{0, 0, 0x777},
	{0, 0, 0x777},
	{0, 0, 0x777},
	{0, 0x777, 0},
	{0, 0x777, 0},
	{0, 0x777, 0},
	{0x777, 0, 0},
	{0x777, 0, 0},
	{0x777, 0, 0},
	
	/* 9 frames */
	{0x444, 0x444, 0x444},
	{0x444, 0x444, 0x444},
	{0x444, 0x444, 0x444},
	{0x222, 0x222, 0x222},
	{0x222, 0x222, 0x222},
	{0x222, 0x222, 0x222},
	{0x111, 0x111, 0x111},
	{0x111, 0x111, 0x111},
	{0x111, 0x111, 0x111},
	
	/* 27 frames */
	{0x400, 0, 0},
	{0x600, 0, 0},
	{0x700, 0, 0},
	{0x740, 0, 0},
	{0x760, 0, 0},
	{0x770, 0, 0},
	{0x774, 0, 0},
	{0x776, 0, 0},
	{0x777, 0, 0},
	{0x777, 0x400, 0},
	{0x777, 0x600, 0},
	{0x777, 0x700, 0},
	{0x777, 0x740, 0},
	{0x777, 0x760, 0},
	{0x777, 0x770, 0},
	{0x777, 0x774, 0},
	{0x777, 0x776, 0},
	{0x777, 0x777, 0},
	{0x777, 0x777, 0x400},
	{0x777, 0x777, 0x600},
	{0x777, 0x777, 0x700},
	{0x777, 0x777, 0x740},
	{0x777, 0x777, 0x760},
	{0x777, 0x777, 0x770},
	{0x777, 0x777, 0x774},
	{0x777, 0x777, 0x776},
	{0x777, 0x777, 0x777},
	
	/* 16 frames */
	{0x421, 0x421, 0x421},
	{0x222, 0x222, 0x222},
	{0x124, 0x124, 0x124},
	{0x070, 0x070, 0x070},
	{0x421, 0x421, 0x421},
	{0x222, 0x222, 0x222},
	{0x124, 0x124, 0x124},
	{0x070, 0x070, 0x070},
	{0x421, 0x421, 0x421},
	{0x222, 0x222, 0x222},
	{0x124, 0x124, 0x124},
	{0x070, 0x070, 0x070},
	{0x421, 0x421, 0x421},
	{0x222, 0x222, 0x222},
	{0x124, 0x124, 0x124},
	{0x070, 0x070, 0x070},
	
	/* 21 frames */
	{0x000, 0x020, 0x000},
	{0x020, 0x272, 0x020},
	{0x272, 0x777, 0x272},
	{0x777, 0x777, 0x777},
	{0x272, 0x777, 0x272},
	{0x020, 0x272, 0x020},
	{0x000, 0x020, 0x000},
	{0x000, 0x020, 0x000},
	{0x020, 0x272, 0x020},
	{0x272, 0x777, 0x272},
	{0x777, 0x777, 0x777},
	{0x272, 0x777, 0x272},
	{0x020, 0x272, 0x020},
	{0x000, 0x020, 0x000},
	{0x000, 0x020, 0x000},
	{0x020, 0x272, 0x020},
	{0x272, 0x777, 0x272},
	{0x777, 0x777, 0x777},
	{0x272, 0x777, 0x272},
	{0x020, 0x272, 0x020},
	{0x000, 0x020, 0x000}
};

int main(void)
{
	int x, rows, y;
    WDTCTL = WDTPW + WDTHOLD;
    
    P2OUT = BIT3 | BIT4 | BIT5;    
    P2DIR |= 0x3F; //All available port 2 pins to outputs
    
    P1OUT = 0xC0; //Pullup on pins 6 and 7
    P1DIR |= 0x3F; //Pins 5 and less as outputs. Pins 6 and 7 as inputs
    
    //Set up timer
 	CCTL0 = CCIE;
 	TACTL = TASSEL_2 + MC_1 + ID_3;
 	CCR0 = 10000; 
    
    //Set up some memory
    ports[0] = &P1OUT;
    ports[1] = &P1OUT;
    ports[2] = &P2OUT;
    
    current_image = animation[0];
    
    // Enable interrupts
    _BIS_SR(GIE);
    
    while (1) 
    {
    	for (rows = 0; rows<3; rows++) 
		{
			P2OUT &= ~(BIT3 | BIT4 | BIT5); //Turn all rows off
			P1OUT |= 0x3F; // Turn columns off
			P2OUT |= 0x07; // Turn rest of columns off
			P2OUT |= 0x1 << (rows + 3); //Turn correct row on
			for (x = 0; x<3; x++)
			{
				for (y = 0; y<3; y++)
				{
					if (((current_image[rows] >> y) >> (x << 2) & 0x1))
					{
						*(ports[x]) &= ~pins[x][y];
					}
				}
			}
			for (volatile int k = 0; k < 200; k++);
    	}
    }
	
	return 0;
}


#pragma vector=TIMER0_A0_VECTOR
__interrupt void timer_A 
(
	void
)
{
	current_frame = current_frame + 1;
	if (current_frame >= NUMBER_OF_FRAMES)
	{
		current_frame = 0;
	} 
	current_image = animation[current_frame];
}


